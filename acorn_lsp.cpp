#include <format>
#include <iostream>
#include <ranges>
#include <unordered_map>

#include "logger.h"

#include "json.hpp"

static Logger logger;

static std::string make_message(const std::string& message) {
    return std::format("Content-Length:{}\r\n\r\n{}", message.size(), message);
}

static std::string trim_leading(const std::string& s) {
    auto view = s | std::views::drop_while(isspace);
    std::string result(view.begin(), view.end());
    return result;
}

enum class MethodRequestId {
#define X(request_string, request_name) request_name,
#include "requests_def.inc"
#undef X
};

std::unordered_map<std::string, MethodRequestId> method_request_mapping;

struct InitializeParams {
    
    /**
     * The process Id of the parent process that started the server. Is null if
     * the process has not been started by another process. If the parent
     * process is not alive then the server should exit (see exit notification)
     * its process.
     */
    int process_id;

    /**
     * The rootPath of the workspace. Is null
     * if no folder is open.
     *
     * @deprecated in favour of `rootUri`.
     */
    std::optional<std::string> root_path;

    /**
     * The rootUri of the workspace. Is null if no
     * folder is open. If both `rootPath` and `rootUri` are set
     * `rootUri` wins.
     *
     * @deprecated in favour of `workspaceFolders`
     */
    std::optional<std::string> root_uri;

};

using json = nlohmann::json;

/*
 * Example parsing function. This should be auto-generated by
 * the transpiler.
 */
static InitializeParams parse_initialize_params(json params) {
    InitializeParams initialize_params = { 0 };
    
    if (params.contains("processId"))
        initialize_params.process_id = params["processId"];

    if (params.contains("root_path"))
        initialize_params.root_path = params["root_path"];

    if (params.contains("root_uri"))
        initialize_params.root_uri = params["root_uri"];
    
    return initialize_params;
}

static void handle_initialize_params(InitializeParams params) {
    logger.info("handling initialization parameters");
    logger.info("process_id: {}", params.process_id);
}

static bool read_message() {

    std::string content_length_msg;
    size_t content_length = 0;
    
    std::cin >> content_length_msg;
    if (content_length_msg != "Content-Length:") {
        logger.error("Recieved uknown protocol header for content length: {}", content_length_msg);
        return false;
    }

    std::cin >> content_length;
    std::string content(content_length + 2, ' '); // +2 for \r\n

    std::streamsize total_read = 0;
    std::cin.read(content.data(), static_cast<std::streamsize>(content_length) + 2);

    try {

        auto body = json::parse(trim_leading(content));

        std::string method = body["method"];

        // Switch based on the method of the request string. Uses a hash map to
        // quickly lookup which function to parse and handle the request.
        switch (method_request_mapping[method]) {
#define X(request_string, request_name) case MethodRequestId :: request_name: { \
            auto params = parse_ ## request_name(body["params"]);               \
            handle_ ## request_name(params);                                    \
            break;                                                              \
            }    
#include "requests_def.inc"
#undef X
        }

    } catch (std::exception& e) {
        logger.error("exception info: {}", e.what());
    }

    return true;
}

int main() {
    //std::cout << make_message("{\"params\":{\"code\":420,\"message\":\"meow\"}}") << '\n';
    
    if (!logger.open()) {
        // Well... what are we suppose to do?
        return 1;
    }
    
    if (!read_message()) {
        return 1;
    }

    //make_message("{}");

    return 0;
}
